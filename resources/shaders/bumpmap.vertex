/* Simple vertex shader with vertex position and normal computation
 */
#version 130
// TODO: set from java to match MAX_TEXTURE_LAYERS there
#define MAX_TEXTURE_LAYERS 4
 
// per vertex input
in vec3 VertexPosition;
in vec3 VertexNormal;
in vec4 VertexTangent;
in vec2 VertexBumpMapCoord;
in vec2 VertexTexCoord0;
in vec2 VertexTexCoord1;
in vec2 VertexTexCoord2;
in vec2 VertexTexCoord3;

// input for at least primitives
uniform mat4 ProjectionMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 NormalMatrix;

uniform bool useLighting;
struct LightInfo {
	vec4 Position; // Light position in world coords.
	vec3 La; // Ambient light intensity
	vec3 Ld; // Diffuse light intensity
	vec3 Ls; // Specular light intensity
};
uniform LightInfo Light;

// output to fragment shader for interpolation
out vec3 LightDirection; // in tangent space
out vec3 VertexEye; // in eye space
out vec2 BumpMapCoord;
out vec2 TexCoord0;
out vec2 TexCoord1;
out vec2 TexCoord2;
out vec2 TexCoord3;
out mat3 TangentMatrix; // transformation from eye space to tangent space

void main()
{
	TexCoord0 = VertexTexCoord0;
	TexCoord1 = VertexTexCoord1;
	TexCoord2 = VertexTexCoord2;
	TexCoord3 = VertexTexCoord3;
	BumpMapCoord = VertexBumpMapCoord;
	
	// Transform to eye coordinates
	vec3 normal = normalize(vec3(NormalMatrix * vec4(VertexNormal, 1.0)));
	vec3 tangent = normalize(vec3(NormalMatrix * vec4(VertexTangent.xyz, 1.0)));
	VertexEye = vec3(ModelViewMatrix * vec4(VertexPosition, 1.0));
	vec4 lightPositionEye = ModelViewMatrix * Light.Position;
	
	// compute bitangent
	vec3 bitangent = normalize( cross( normal, tangent ) ) * VertexTangent.w;
	
	// transformation to tangent space
	TangentMatrix = mat3(
		tangent.x, bitangent.x, normal.x,
		tangent.y, bitangent.y, normal.y,
		tangent.z, bitangent.z, normal.z );
	
	// transform light to tangent space
	// directional light?
	if( Light.Position.w == 0.0 )
		LightDirection = normalize( TangentMatrix * vec3(lightPositionEye) );
	else
		LightDirection = normalize( TangentMatrix * (vec3(lightPositionEye) - VertexEye) );
	
	gl_Position = ModelViewProjectionMatrix * vec4(VertexPosition, 1.0);
} 
