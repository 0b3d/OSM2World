/* Simple vertex shader with vertex position and normal computation
 */
#version 130
// TODO: set from java to match MAX_TEXTURE_LAYERS there
#define MAX_TEXTURE_LAYERS 4
 
// per vertex input
in vec3 VertexPosition;
in vec3 VertexNormal;
in vec4 VertexTangent;
in vec2 VertexBumpMapCoord;
in vec2 VertexTexCoord0;
in vec2 VertexTexCoord1;
in vec2 VertexTexCoord2;
in vec2 VertexTexCoord3;

// input for at least primitives
uniform mat4 ProjectionMatrix;
uniform mat4 ModelViewMatrix;
uniform mat4 ModelViewProjectionMatrix;
uniform mat4 NormalMatrix;

// output to fragment shader for interpolation
out vec3 VertexEye; // in eye space
out vec2 BumpMapCoord;
out mat3 TangentMatrix; // transformation from eye space to tangent space
out vec2 TexCoord0;
out vec2 TexCoord1;
out vec2 TexCoord2;
out vec2 TexCoord3;

void main()
{
	TexCoord0 = VertexTexCoord0;
	TexCoord1 = VertexTexCoord1;
	TexCoord2 = VertexTexCoord2;
	TexCoord3 = VertexTexCoord3;
	BumpMapCoord = VertexBumpMapCoord;
	
	// Transform to eye coordinates
	vec3 normal = normalize(vec3(NormalMatrix * vec4(VertexNormal, 1.0)));
	vec3 tangent = normalize(vec3(NormalMatrix * vec4(VertexTangent.xyz, 1.0)));
	VertexEye = vec3(ModelViewMatrix * vec4(VertexPosition, 1.0));
	
	// compute bitangent
	vec3 bitangent = normalize( cross( normal, tangent ) ) * VertexTangent.w;
	
	// transformation to tangent space
	TangentMatrix = mat3(
		tangent.x, bitangent.x, normal.x,
		tangent.y, bitangent.y, normal.y,
		tangent.z, bitangent.z, normal.z );
	
	gl_Position = ModelViewProjectionMatrix * vec4(VertexPosition, 1.0);
} 
